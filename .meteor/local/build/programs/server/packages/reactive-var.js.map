{"version":3,"file":"/packages/reactive-var.js","sources":["reactive-var/reactive-var.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA,E;AACA,mD;AACA,E;AACA,8D;AACA,gE;AACA,6D;AACA,gB;AACA,E;AACA,uE;AACA,yE;AACA,sE;AACA,0E;AACA,E;AACA,uE;AACA,wE;AACA,8D;AACA,qE;AACA,kE;AACA,uE;AACA,uE;AACA,yE;AACA,qE;AACA,sC;AACA,E;AACA,qE;AACA,8D;AACA,G;;AAEA,mD;AACA,sC;AACA,2B;AACA,qD;;AAEA,+B;AACA,+B;AACA,oC;AACA,E;;AAEA,sD;AACA,iC;AACA,0D;AACA,iD;AACA,c;AACA,iB;AACA,M;AACA,0E;AACA,qC;AACA,E;;AAEA,yC;AACA,qB;AACA,sB;;AAEA,uB;AACA,E;;AAEA,iD;AACA,+B;;AAEA,oE;AACA,iC;AACA,W;;AAEA,2B;AACA,qB;AACA,E;;AAEA,8C;AACA,2C;AACA,E;;AAEA,kD;AACA,wB;AACA,oD;AACA,gB;AACA,0C;AACA,Y;AACA,e;AACA,E","sourcesContent":["/*\n * ## [new] ReactiveVar(initialValue, [equalsFunc])\n *\n * A ReactiveVar holds a single value that can be get and set,\n * such that calling `set` will invalidate any Computations that\n * called `get`, according to the usual contract for reactive\n * data sources.\n *\n * A ReactiveVar is much like a Session variable -- compare `foo.get()`\n * to `Session.get(\"foo\")` -- but it doesn't have a global name and isn't\n * automatically migrated across hot code pushes.  Also, while Session\n * variables can only hold JSON or EJSON, ReactiveVars can hold any value.\n *\n * An important property of ReactiveVars, which is sometimes the reason\n * to use one, is that setting the value to the same value as before has\n * no effect, meaning ReactiveVars can be used to absorb extra\n * invalidations that wouldn't serve a purpose.  However, by default,\n * ReactiveVars are extremely conservative about what changes they\n * absorb.  Calling `set` with an object argument will *always* trigger\n * invalidations, because even if the new value is `===` the old value,\n * the object may have been mutated.  You can change the default behavior\n * by passing a function of two arguments, `oldValue` and `newValue`,\n * to the constructor as `equalsFunc`.\n *\n * This class is extremely basic right now, but the idea is to evolve\n * it into the ReactiveVar of Geoff's Lickable Forms proposal.\n */\n\nReactiveVar = function (initialValue, equalsFunc) {\n  if (! (this instanceof ReactiveVar))\n    // called without `new`\n    return new ReactiveVar(initialValue, equalsFunc);\n\n  this.curValue = initialValue;\n  this.equalsFunc = equalsFunc;\n  this.dep = new Tracker.Dependency;\n};\n\nReactiveVar._isEqual = function (oldValue, newValue) {\n  var a = oldValue, b = newValue;\n  // Two values are \"equal\" here if they are `===` and are\n  // number, boolean, string, undefined, or null.\n  if (a !== b)\n    return false;\n  else\n    return ((!a) || (typeof a === 'number') || (typeof a === 'boolean') ||\n            (typeof a === 'string'));\n};\n\nReactiveVar.prototype.get = function () {\n  if (Tracker.active)\n    this.dep.depend();\n\n  return this.curValue;\n};\n\nReactiveVar.prototype.set = function (newValue) {\n  var oldValue = this.curValue;\n\n  if ((this.equalsFunc || ReactiveVar._isEqual)(oldValue, newValue))\n    // value is same as last time\n    return;\n\n  this.curValue = newValue;\n  this.dep.changed();\n};\n\nReactiveVar.prototype.toString = function () {\n  return 'ReactiveVar{' + this.get() + '}';\n};\n\nReactiveVar.prototype._numListeners = function() {\n  // Tests want to know.\n  // Accesses a private field of Tracker.Dependency.\n  var count = 0;\n  for (var id in this.dep._dependentsById)\n    count++;\n  return count;\n};\n"]}