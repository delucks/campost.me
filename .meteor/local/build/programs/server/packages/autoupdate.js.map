{"version":3,"file":"/packages/autoupdate.js","sources":["autoupdate/autoupdate_server.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAAA,oE;AACA,sE;AACA,iD;AACA,E;AACA,2E;AACA,8E;AACA,8E;AACA,2D;AACA,gE;AACA,E;AACA,qE;AACA,mE;AACA,gE;AACA,mE;AACA,gE;AACA,uB;AACA,E;AACA,gE;AACA,sB;AACA,E;AACA,4D;AACA,qE;AACA,yE;AACA,qE;AACA,iE;AACA,0E;AACA,8E;AACA,yE;AACA,mE;AACA,qB;AACA,E;AACA,0E;AACA,+E;AACA,2E;AACA,2C;;AAEA,0C;;AAEA,gB;;AAEA,gD;AACA,yE;AACA,wB;;AAEA,oE;AACA,iE;AACA,kE;AACA,qB;;AAEA,2E;AACA,W;AACA,oC;AACA,+C;;AAEA,+C;;AAEA,uE;AACA,2D;AACA,yE;AACA,8C;AACA,kC;AACA,0C;AACA,G;;AAEA,6E;AACA,2B;AACA,2E;AACA,kC;AACA,uC;AACA,kD;AACA,iD;AACA,G;AACA,yE;AACA,oD;AACA,+C;AACA,iC;;AAEA,2C;AACA,4D;AACA,uC;AACA,kD;AACA,8C;;AAEA,uE;AACA,0C;AACA,kC;AACA,0C;AACA,G;;AAEA,0B;AACA,kD;AACA,+D;AACA,+D;AACA,8B;AACA,2C;AACA,G;;AAEA,mD;AACA,2B;AACA,qB;AACA,4C;AACA,O;AACA,U;AACA,8C;AACA,4C;AACA,Q;AACA,G;;AAEA,+D;AACA,2B;AACA,iC;AACA,uD;AACA,+C;AACA,O;AACA,U;AACA,0D;AACA,uD;AACA,+C;AACA,Q;AACA,G;AACA,E;;AAEA,e;AACA,qC;AACA,e;AACA,iC;AACA,I;AACA,iB;AACA,E;;AAEA,4B;AACA,wB;AACA,G;;AAEA,uB;;AAEA,mE;AACA,2E;AACA,uE;AACA,yE;AACA,gF;;AAEA,iC;AACA,a;AACA,G;;AAEA,gC;AACA,e;AACA,G;;AAEA,qE;AACA,0D;AACA,mC;AACA,yB;AACA,K;AACA,I","sourcesContent":["// Publish the current client versions to the client.  When a client\n// sees the subscription change and that there is a new version of the\n// client available on the server, it can reload.\n//\n// By default there are two current client versions. The refreshable client\n// version is identified by a hash of the client resources seen by the browser\n// that are refreshable, such as CSS, while the non refreshable client version\n// is identified by a hash of the rest of the client assets\n// (the HTML, code, and static files in the `public` directory).\n//\n// If the environment variable `AUTOUPDATE_VERSION` is set it will be\n// used as the client id instead.  You can use this to control when\n// the client reloads.  For example, if you want to only force a\n// reload on major changes, you can use a custom AUTOUPDATE_VERSION\n// which you only change when something worth pushing to clients\n// immediately happens.\n//\n// For backwards compatibility, SERVER_ID can be used instead of\n// AUTOUPDATE_VERSION.\n//\n// The server publishes a `meteor_autoupdate_clientVersions`\n// collection. There are two documents in this collection, a document\n// with _id 'version' which represnets the non refreshable client assets,\n// and a document with _id 'version-refreshable' which represents the\n// refreshable client assets. Each document has a 'version' field\n// which is equivalent to the hash of the relevant assets. The refreshable\n// document also contains a list of the refreshable assets, so that the client\n// can swap in the new assets without forcing a page refresh. Clients can\n// observe changes on these documents to detect when there is a new\n// version available.\n//\n// In this implementation only two documents are present in the collection\n// the current refreshable client version and the current nonRefreshable client\n// version.  Developers can easily experiment with different versioning and\n// updating models by forking this package.\n\nvar Future = Npm.require(\"fibers/future\");\n\nAutoupdate = {};\n\n// The collection of acceptable client versions.\nClientVersions = new Mongo.Collection(\"meteor_autoupdate_clientVersions\",\n  { connection: null });\n\n// The client hash includes __meteor_runtime_config__, so wait until\n// all packages have loaded and have had a chance to populate the\n// runtime config before using the client hash as our default auto\n// update version id.\n\n// Note: Tests allow people to override Autoupdate.autoupdateVersion before\n// startup.\nAutoupdate.autoupdateVersion = null;\nAutoupdate.autoupdateVersionRefreshable = null;\n\nvar syncQueue = new Meteor._SynchronousQueue();\n\n// updateVersions can only be called after the server has fully loaded.\nvar updateVersions = function (shouldReloadClientProgram) {\n  // Step 1: load the current client program on the server and update the\n  // hash values in __meteor_runtime_config__.\n  if (shouldReloadClientProgram) {\n    WebAppInternals.reloadClientProgram();\n  }\n\n  // If we just re-read the client program, or if we don't have an autoupdate\n  // version, calculate it.\n  if (shouldReloadClientProgram || Autoupdate.autoupdateVersion === null) {\n    Autoupdate.autoupdateVersion =\n      process.env.AUTOUPDATE_VERSION ||\n      process.env.SERVER_ID || // XXX COMPAT 0.6.6\n      WebApp.calculateClientHashNonRefreshable();\n  }\n  // If we just recalculated it OR if it was set by (eg) test-in-browser,\n  // ensure it ends up in __meteor_runtime_config__.\n  __meteor_runtime_config__.autoupdateVersion =\n    Autoupdate.autoupdateVersion;\n\n  Autoupdate.autoupdateVersionRefreshable =\n    __meteor_runtime_config__.autoupdateVersionRefreshable =\n      process.env.AUTOUPDATE_VERSION ||\n      process.env.SERVER_ID || // XXX COMPAT 0.6.6\n      WebApp.calculateClientHashRefreshable();\n\n  // Step 2: form the new client boilerplate which contains the updated\n  // assets and __meteor_runtime_config__.\n  if (shouldReloadClientProgram) {\n    WebAppInternals.generateBoilerplate();\n  }\n\n  // XXX COMPAT WITH 0.8.3\n  if (! ClientVersions.findOne({current: true})) {\n    // To ensure apps with version of Meteor prior to 0.9.0 (in\n    // which the structure of documents in `ClientVersions` was\n    // different) also reload.\n    ClientVersions.insert({current: true});\n  }\n\n  if (! ClientVersions.findOne({_id: \"version\"})) {\n    ClientVersions.insert({\n      _id: \"version\",\n      version: Autoupdate.autoupdateVersion,\n    });\n  } else {\n    ClientVersions.update(\"version\", { $set: {\n      version: Autoupdate.autoupdateVersion,\n    }});\n  }\n\n  if (! ClientVersions.findOne({_id: \"version-refreshable\"})) {\n    ClientVersions.insert({\n      _id: \"version-refreshable\",\n      version: Autoupdate.autoupdateVersionRefreshable,\n      assets: WebAppInternals.refreshableAssets\n    });\n  } else {\n    ClientVersions.update(\"version-refreshable\", { $set: {\n      version: Autoupdate.autoupdateVersionRefreshable,\n      assets: WebAppInternals.refreshableAssets\n    }});\n  }\n};\n\nMeteor.publish(\n  \"meteor_autoupdate_clientVersions\",\n  function () {\n    return ClientVersions.find();\n  },\n  {is_auto: true}\n);\n\nMeteor.startup(function () {\n  updateVersions(false);\n});\n\nvar fut = new Future();\n\n// We only want SIGUSR2 to trigger 'updateVersions' AFTER onListen,\n// so we add a queued task that waits for onListen before SIGUSR2 can queue\n// tasks. Note that the `onListening` callbacks do not fire until after\n// Meteor.startup, so there is no concern that the 'updateVersions' calls\n// from SIGUSR2 will overlap with the `updateVersions` call from Meteor.startup.\n\nsyncQueue.queueTask(function () {\n  fut.wait();\n});\n\nWebApp.onListening(function () {\n  fut.return();\n});\n\n// Listen for SIGUSR2, which signals that a client asset has changed.\nprocess.on('SIGUSR2', Meteor.bindEnvironment(function () {\n  syncQueue.queueTask(function () {\n    updateVersions(true);\n  });\n}));\n"]}